1. redis 是什么？ 简述它的优缺点？

   Redis本质上是一个 Key-Value类型的内存数据库，整个数据库加载在内存当中进行操作，定期通过异步操作把数据库数据flush 到硬盘上进行保存。 
   因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10 万次读写操作，是已知性能最快的Key-Value  DB。 

   Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value 的最大限制是1GB，不像  memcached只能保存1MB 的数据，因此Redis可以用来实现很多有用的功能。 
   比方说用他的List 来做FIFO双向链表，实现一个轻量级的高性能消息队列服务，用他的Set 可以做高性能的tag系统等等。 
   另外Redis也可以对存入的 Key-Value设置expire 时间，因此也可以被当作一个功能加强版的memcached 来用。

   **Redis的主要缺点**是**数据库容量受到物理内存的限制**，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。 

2. .为什么 redis 是单线程的都那么快？

   1)数据存于内存 
   2).用了多路复用I/O 
   3).单线程 

3. 、Redis相比memcached有哪些优势？ 

   (1)  memcached所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型 
   (2)  redis 的速度比memcached快很多 
   (3)  redis 可以持久化其数据 

4. 为什么Redis需要把所有数据放到内存中？

   Redis**为了达到最快的读写速度**将数据都读到内存中，并**通过异步的方式**将数据写入磁盘。 
   所以redis 具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度会严重影响redis 的性能。 
   在内存越来越便宜的今天，redis 将会越来越受欢迎。  如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。 

5. redis 也可以进行发布订阅消息吗？

   可以，（然后可以引出哨兵模式（后面会讲）怎么互相监督的，就是因为每隔 2秒哨兵节点会发布对某节点的判断和自身的信息到某频道，每个哨兵订阅该频道获取其他哨兵节点和主从节点的信息，以达到哨兵间互相监控和对主从节点的监控）和很多专业的消息队列系统（例如Kafka、RocketMQ）相比，Redis的发布订阅略显粗糙，例如无法实现消息堆积和回溯。但胜在足够简单。

6. redis 能否将数据持久化，如何实现？

   能，将内存中的数据异步写入硬盘中，两种方式：RDB（默认）和 AOF **RDB持久化原理**：通过 bgsave 命令触发，然后父进程执行 fork操作创建子进程，子进程创建 RDB 文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换（定时一次性将所有数据进行快照生成一份副本存储在硬盘中） 
   优点：是一个紧凑压缩的二进制文件，Redis加载RDB 恢复数据远远快于 AOF的方式。 
   缺点：由于每次生成 RDB 开销较大，非实时持久化

   **AOF持久化原理**：开启后，Redis每执行一个**修改数据的命令**，都会把这个命令添加到 AOF文件中。 
   优点：实时持久化。 
   缺点：所以 AOF 文件体积逐渐变大，需要定期执行重写操作来降低文件体积，加载慢 

7. .主从复制模式下，主挂了怎么办？

   主从复制: 为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1 个复制品.

   redis 提供了哨兵模式（高可用） 

   何谓**哨兵模式**？就是**通过哨兵节点进行自主监控主从节点以及其他哨兵节点，发现主节点故障时自主进行故障转移。**

8. Redis集群方案应该怎么做？都有哪些方案？

   0.twemproxy，大概概念是，它类似于一个代理方式，使用方法和普通 Redis无任何区别，设置好它下属的多个 Redis 实例后，使用时在本需要连接 Redis 的地方改为连接
   twemproxy，它会以一个代理的身份接收请求并**使用一致性 hash 算法**，将请求转接到具
   体 Redis，将结果再返回 twemproxy。使用方式简便(相对 Redis只需修改连接端口)，对
   旧项目扩展的首选。 

   问题：twemproxy 自身单端口实例的压力，使用一致性 hash 后，对Redis节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。

   1.codis。 
   目前用的最多的集群方案，基本和twemproxy 一致的效果，但它支持在节点数量改变情况下，旧节点数据可恢复到新hash 节点。 
   2.redis  cluster3.0 自带的集群，特点在于**他的分布式算法不是一致性hash，而是hash槽的概念，**以及自身支持节点设置从节点。具体看官方文档介绍。 
   3.在业务代码层实现，起几个毫无关联的redis 实例，在代码层，对key  进行hash 计算，然后去对应的redis 实例操作数据。  这种方式对hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。 

9. 、Redis集群方案什么情况下会导致整个集群不可用？ 

   有A，B，C 三个节点的集群,**在没有复制模型的情况下**,如果节点B 失败了，那么整个集群就会以为缺少5501-11000 这个范围的槽而不可用。 

10. 哨兵模式实现原理？

    1.三个定时监控任务： 
    1.1 每隔 10s，每个 S 节点（哨兵节点）会向主节点和从节点发送 info 命令获取最新的拓扑结构 

    1.2 每隔 2s，每个 S 节点会向某频道上发送该 S 节点对于主节点的判断以及当前 Sl 节点的信息， 同时每个 Sentinel 节点也会订阅该频道，来了解其他 S 节点以及它们对主节点的判断（做客观下线依据） 
    1.3 每隔1s，每个 S 节点会向主节点、从节点、其余S 节点发送一条 ping 命令做一次心跳检测(心跳检测机制)，来确认这些节点当前是否可达 

    2.主客观下线： 
    2.1 主观下线：根据第三个定时任务对没有有效回复的节点做主观下线处理 
    2.2 客观下线：若主观下线的是主节点，会咨询其他 S 节点对该主节点的判断，超过半数，对该主节点做客观下线 
    3.选举出某一哨兵节点作为领导者，来进行故障转移。

    选举方式：raft算法。每个S 节点有一票同意权，哪个 S 节点做出主观下线的时候，就会询问其他 S 节点是否同意其为领导者。获得半数选票的则成为领导者。基本谁先做出客观下线，谁成为领导者。 
    4.故障转移（选举新主节点流程）

11. .缓存更新策略（即如何让缓存和mysql保持一致性）？

    1）key过期清除（超时剔除）策略 

    **惰性过期**（类比懒加载，这是懒过期）：<u>只有当访问一个key 时，才会判断该key是否已过期，过期则清除</u>。该策略可以最大化地节省 CPU 资源，却对内存非常不友好。极端情况可能出现大量的过期key 没有再次被访问，从而不会被清除，占用大量内存。 
    **定期过期**：每隔一定的时间，会扫描一定数量的数据库的 expires字典中一定数量的 key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果。 (expires字典会保存所有设置了过期时间的key 的过期时间数据，其中，key 是指向键空间中的某个键的指针，value 是该键的毫秒精度的 UNIX 时间戳表示的过期时间。键空间是指该 Redis集群中保存的所有键。) 

    问：比如这么个场景，我设计了很多key，过期时间是5 分钟，当前内存占用率是 50%。但是 5 分钟到了，内存占用率还是很高，请问为什么？ 
    Redis中同时使用了惰性过期和定期过期两种过期策略，即使过期时间到了，但是有部分并没有真正删除，等待惰性删除。 为什么有定期还要有惰性呢？其实很简单，比如 10 万个 key 就要过期了， Redis默认是 100ms 检查一波。如果他检查出 10 万个即将要清除，那他接下来的时间基本都是在干这些清空内存的事了，那肯定影响性能，所以他只会部分删除，剩下的等惰性。 

    2）Redis 的内存淘汰策略 

    Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。 
    noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。 

    allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，**移除最近最少使用的 key**。 
    allkeys-random：当内存不足以容纳新写入数据时，在键空间中，**随机移除某个key**。 
    volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，**移除最近最少使用的 key**。 
    volatile-random：当内存不足以容纳新写入数据时**，在设置了过期时间的键空间中，随机移除某个 key**。 
    volatile-ttl：当内存不足以容纳新写入数据时**，在设置了过期时间的键空间中，有更早过期时间的key 优先移除**。

12. .如何防止缓存穿透？ 

    （缓存穿透指的是查询一个根本不存在的数据，缓存层不命中，又去查存储层，又不命中。但如果有大量这种查询不存在的数据的请求过来，会对存储层有较大压力，若是恶意攻击，后果就） 
    12.1：缓存空值存在的问题： 
    12.2：布隆过滤器： 

    布隆过滤器存在的问题：相对来说布隆过滤器搞起来代码还是比较复杂的，现阶段我们暂时还不需要，后面实在需要再考虑去做，什么阶段做什么样的事情，不是说这个系统一下子就能做的各种完美。 

13. 无底洞优化？ 

    造成原因：redis 分布式越来越多，导致性能反而下降，因为键值分布到更多的 节点上，所以无论是 Memcache 还是 Redis的分布式，批量操作通常需要从不同节点上获取，相比于单机批量操作只涉及一次网络操作，分布式批量操作会涉及多次网络时间。 即分布式过犹不及。

14. 雪崩优化 

    如果缓存层由于某些原因不能提供服务，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会级联宕机的情况。 

15. .热点 key 优化 

    当前 key 是一个热点 key（例如一个热门的娱乐新闻），并发量非常大。

16. MySQL 里有2000w数据，redis 中只存20w 的数据，如何保证redis中的数据都是热点数据？ 
    redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。

17. Redis有哪些适合的场景？ 

    （1）会话缓存（Session  Cache） 
    最常用的一种使用Redis的情景是会话缓存（session  cache）。用 Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？ 
    幸运的是，随着  Redis  这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento 也提供Redis的插件。 
    （2）全页缓存（FPC） 
    除基本的会话token 之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了 Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP 本地FPC。 再次以Magento 为例，Magento 提供一个插件来使用Redis作为全页缓存后端。 
    此外，对WordPress 的用户来说，Pantheon有一个非常好的插件  wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。 
    （3）队列 
    Reids在内存存储引擎领域的一大优点是提供  list  和  set  操作，这使得 Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对  list  的  push/pop 操作。 

    （4）排行榜/计数器 
    Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted  Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。 
    所以，我们要从排序集合中获取到排名最靠前的10 个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可： 
    当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行： 
    ZRANGE  user_scores  0  10 WITHSCORES 

    Agora  Games 就是一个很好的例子，用Ruby 实现的，它的排行榜就是使用 Redis来存储数据的，你可以在这里看到。 
    （5）发布/订阅 
    最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！ 

18. Jedis 与Redisson对比有什么优缺点？ 

    **Jedis 是Redis的Java 实现的客户端**，其API提供了比较全面的Redis命令的支持； 
    **Redisson实现了分布式和可扩展的Java 数据结构**，和Jedis 相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。 

19. 说说Redis哈希槽的概念？ 

    **Redis集群没有使用一致性 hash**,而是引入了哈希槽的概念，**Redis集群有16384个哈希槽**，每个key 通过CRC16校验后对16384取模来决定放置哪个槽，**集群的每个节点负责一部分hash 槽。** 

20. Redis集群会有写操作丢失吗？为什么？ 

    Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。 

21. Redis集群如何选择数据库？

    Redis集群目前无法做数据库选择，默认在0 数据库。 

22. Redis中的管道有什么用？ 

    一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。 
    这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多POP3协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。 

23. 怎么理解Redis事务？ 

    事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 
    事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。

24. Redis事务相关的命令有哪几个？ 

    MULTI、EXEC、DISCARD、WATCH

25. Redis如何做内存优化？ 

    **尽可能使用散列表（hashes**），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。 
    比如你的web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key, 而是应该**把这个用户的所有信息存储到一张散列表里面**。 

26. Redis回收进程如何工作的？

    一个客户端运行了新的命令，添加了新的数据。 
    Redis 检查内存使用情况，**如果大于maxmemory 的限制, 则根据设定好的策略进行回收。** 
    一个新的命令被执行，等等。 
    所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。 
    如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。 

27. Redis 如何做大量数据插入？

    Redis2.6开始Redis-cli支持一种新的被称之为**pipe mode的新模式**用于执行大量数据插入工作.

28. 为什么要做 Redis 分区？

    **分区可以让 Redis 管理更大的内存，Redis 将可以使用所有机器的内存。**如果没有分区，你最多只能使用一台机器的内存。 分区使 Redis 的计算能力通过简单地增加计算机得到成倍提升,Redis 的网络带宽也会随着计算机和网卡的增加而成倍增长。

29. 有哪些 Redis 分区实现方案？

    **客户端分区**：就是在客户端就已经决定数据会被存储到哪个 Redis 节点或者从哪个 Redis节点读取。大多数客户端已经实现了客户端分区。

    **代理分区：**意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。
    代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。
    Redis和 memcached 的一种代理实现就是 Twemproxy查询路由(Query routing) 的意思是客户端随机地请求任意一个 Redis实例， 然后由 Redis将请求转发给正确的 Redis节点。Redis Cluster 实现了一种混合形式的查询路由，但并不是直接将请求从一个 Redis 节点转发到另一个 Redis 节点，而是在客户端的帮助下直接redirected 到正确的 Redis节点。

30. Redis 分区有什么缺点？

    涉及多个 key 的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的 Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。
    同时操作多个 key,则不能使用 Redis事务.
    分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集 （The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set）.
    当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的 Redis 实例和主机同时收集 RDB / AOF 文件。
    分区时动态扩容或缩容可能非常复杂。Redis 集群在运行时增加或者删除 Redis 节点，能做到最大程度对用户透明地数据再平衡， 但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。

31. **使用 redis如何设计分布式锁？说一下实现思路？使用 zk 可以吗？如何实现？这两种有什么区别？** 
    redis: 
    1).线程A setnx(上锁的对象,超时时的时间戳t1)，如果返回true，获得锁。 
    2).线程B  用get 获取t1,与当前时间戳比较,判断是是否超时,没超时false,若超时执行第3步; 
    3).计算新的超时时间t2,使用getset命令返回 t3(该值可能其他线程已经修改过),如果t1==t3，获得锁，如果t1!=t3 说明锁被其他线程获取了。 
    4).获取锁后，处理完业务逻辑，再去判断锁是否超时，如果没超时删除锁，如果已超时，不用处理（防止删除其他线程的锁）。 

    zk: 
    1).客户端对某个方法加锁时，在zk上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点node1; 
    2).客户端获取该路径下所有已经创建的子节点，如果发现自己创建的node1的序号是最小的，就认为这个客户端获得了锁。 
    3).如果发现node1不是最小的，则监听比自己创建节点序号小的最大的节点，进入等待。 4.获取锁后，处理完逻辑，删除自己创建的node1即可。 
    区别:zk性能差一些，开销大，实现简单。 

32. **缓存穿透、缓存击穿、缓存雪崩解决方案？** 

    **缓存穿透**：指查询一个一定不存在的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到DB 去查询，可能导致DB 挂掉。 
    解决方案：

    1).查询返回的数据为空，仍把这个空结果进行缓存，但过期时间会比较短；

    2).布隆过滤器：将所有可能存在的数据哈希到一个足够大的bitmap 中，一个一定不存在的数据会被这个bitmap 拦截掉，从而避免了对 DB 的查询。 
    **缓存击穿**：对于设置了过期时间的key，缓存在某个时间点过期的时候，恰好这时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把DB 压垮。 

    解决方案：

    1).使用互斥锁：当缓存失效时，不立即去load  db，先使用如Redis 的setnx 去设置一个互斥锁，当操作成功返回时再进行load  db 的操作并回设缓存，否则重试get 缓存的方法。

    2).永远不过期：物理不过期，但逻辑过期（后台异步线程去刷新） 。 
    **缓存雪崩**：设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB 瞬时压力过重雪崩。与缓存击穿的区别：雪崩是很多key，击穿是某一个key缓存。 
    解决方案：

    将缓存失效时间分散开，比如可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。 