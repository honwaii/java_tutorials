1. **⼯⼚⽅法模式**(利⽤创建同⼀接⼝的不同实例)：

   1) 普通⼯⼚模式：建⽴⼀个⼯⼚类，对实现了同⼀接⼝的⼀些类进⾏实例的创建；

   ```java
   public class SendFactory {  
       public Sender produce(String type) {  
           if ("mail".equals(type)) {  
               return new MailSender();  
           } else if ("sms".equals(type)) {  
               return new SmsSender();  
           } else {  
               System.out.println("请输⼊正确的类型!");
               return null;  
           }  
       }  
   } 
   ```
   2) 多个⼯⼚⽅法模式：提供多个⼯⼚⽅法，分别创建对象；

   ```java
   public class SendFactory {  
       public Sender produceMail(){  
           return new MailSender();  
       }  
       public Sender produceSms(){  
           return new SmsSender();  
       }  
   } 
   ```

   3) 静态⼯⼚⽅法模式：将上⾯的多个⼯⼚⽅法置为静态的，不需要创建⼯⼚实例，直接调⽤即可；

   4) 适⽤场景：凡是出现了**⼤量不同种类的产品需要创建**，**并且具有共同的接⼝**时，可以通过⼯⼚⽅法模式进⾏创建。在以上的三种模式中，第⼀种如果传⼊的字符串有误，不能正确创建对象，第三种相对于第⼆种，不需要实例化⼯⼚类，所以，⼤多数情况下，我们会选⽤第三种——**静态⼯⼚⽅法模式**。

2. **抽象⼯⼚模式**(多个⼯⼚)：创建多个⼯⼚类，提⾼⼯⼚的扩展性，不⽤像上⾯⼀样如果增加产品则要去修改唯⼀的⼯⼚类；

3. **单例模式**(保证对象只有⼀个实例)：保证在⼀个JVM中，该对象只有⼀个实例存在；

   1) 适⽤场景：
                a. 某些类创建⽐较频繁，对于⼀些⼤型的对象，这是⼀笔很⼤的系统开销。
                b. 省去了new操作符，降低了系统内存的使⽤频率，减轻GC压⼒。
                c. 有些类如交易所的核⼼交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（⽐如⼀个军队出现了多个司令员同时指挥，肯定会乱成⼀团），所以只有使⽤单例模式，才能保证核⼼交易服务器独⽴控制整个流程。

4. **原型模式**: (对⼀个原型对象进⾏复制、克隆产⽣类似新对象)：<u>将⼀个对象作为原型，对其进⾏复制、克隆</u>，产⽣⼀个和元对象类似的新对象；
           1) 核⼼：它的核⼼是原型类Prototype，**需要实现Cloneable接⼝，和重写Object类中的clone⽅法；**
           2) 作⽤：使⽤原型模式创建对象⽐直接new⼀个对象在性能上要好的多，因为Object类的clone⽅法是⼀个本地⽅法，它直接操作内存中的⼆进制流，特别是**复制⼤对象时，性能的差别⾮常明显**。

5. **适配器模式**(接⼝兼容)：将某个类的接⼝转换成客户端期望的另⼀个接⼝表示，⽬的是**消除由于接⼝不匹配所造成的类的兼容性问题。**
   1) 分类：

   ​	a）类的适配器模式: 
   ​      核心思想： 有一个Source类， 拥有一个方法，待适配，目标接口是Targetable,通过Adapter 类，将Source的功能扩展到Targetable里。（建一个新类继承Source并实现 Targetable.)
   ​	b）对象的适配器模式：
   ​	c)  接口的适配器模式: 

   2) 使⽤场景：
   	a. 类的适配器模式：当希望将⼀个类转换成满⾜另⼀个新接⼝的类时，可以使⽤类的适配器模式，创建⼀个新类，继承原有的类实现新的接⼝即可。
   	b.对象的适配器模式：当希望**将⼀个对象转换成满⾜另⼀个新接⼝的对象**时，可以创建⼀个Wrapper类，持有原类的⼀个实例，在Wrapper类的⽅法中，调⽤实例的⽅法就⾏。
   	c. 接⼝的适配器模式：当**不希望实现⼀个接⼝中所有的⽅法**时，可以创建⼀个抽象类Wrapper，实现所有⽅法，我们写别的类的时候，继承抽象类即可。   
   
6. 装饰模式(给对象动态增加新功能，需持有对象实例)：装饰模式就是**给⼀个对象增加⼀些新的功能，⽽且是动态的**，<u>要求装饰对象和被装饰对象实现同⼀个**接⼝</u>**，装饰对象持有被装饰对象的实例.
      使⽤场景：
      1) 需要扩展⼀个类的功能。
      2) 动态的为⼀个对象增加功能，⽽且还能动态撤销。（继承不能做到这⼀点，继承的功能是静态的，不能动态增删。）

7. **代理模式**(持有被代理类的实例，进⾏操作前后控制)：采⽤⼀个代理类调⽤原有的⽅法，且对产⽣的结果进⾏控制。

8. 外观模式(**集合所有操作到⼀个类**)：外观模式是为了**解决类与类之间的依赖关系的**，像spring⼀样，可以将类和类之间的关系配置到配置⽂件中，⽽外观模式就是将他们的关系放在⼀个Facade类中，降低了类类之间的耦合度。

9. **桥接模式**(数据库驱动桥接)：桥接模式就是把事物和其具体实现分开，使他们可以各⾃独⽴的变化。桥接的⽤意是：将抽象化与实现化解耦，使得⼆者可以独⽴变化，像我们常⽤的JDBC桥DriverManager⼀样，JDBC进⾏连接数据库的时候，在各个数据库之间进⾏切换，基本不需要动太多的代码，甚⾄丝毫不⽤动，原因就是JDBC提供统⼀接⼝，每个数据库提供各⾃的实现，⽤⼀个叫做数据库驱动的程序来桥接就⾏了。

10. **组合模式**(部分整体模式)：组合模式有时⼜叫部分-整体模式在**处理类似树形结构的问题时⽐较⽅便**。

11. **享元模式**(共享池、数据库连接池)：享元模式的主要⽬的是**实现对象的共享，即共享池**，当系统中对象多的时候可以减少内存的开销，**通常与⼯⼚模式⼀起使⽤**。当⼀个客户端请求时，⼯⼚需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建⼀个新对象，如数据库连接池；

12. **策略模式**(多种算法封装)：策略模式定义了⼀系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使⽤算法的客户。需要设计⼀个接⼝，为⼀系列实现类提供统⼀的⽅法，多个实现类实现该接⼝.

13. **模板⽅法模式**(抽象⽅法作为⻣架，具体逻辑让⼦类实现)：定义⼀个操作中算法的框架，⽽将⼀些步骤延迟到⼦类中，使得⼦类可以不改变算法的结构即可重定义该算法中的某些特定步骤。完成公共动作和特殊动作的分离.

14. <u>**观察者模式**(发布-订阅模式)</u>：当⼀个对象变化时，其<u>它依赖该对象的对象都会收到通知</u>，并且随着变化！对象之间是⼀种⼀对多的关系。类似于邮件订阅和RSS订阅，当你订阅了该⽂章，如果后续有更新，会及时通知你。

15. 迭代器模式(遍历集合)：迭代器模式就是顺序访问聚集中的对象。

16. **责任链模式**(多任务形成⼀条链，请求在链上传递)：有多个对象，每个对象持有对下⼀个对象的引⽤，这样就会形成⼀条链，请求在这条链上传递，直到某⼀对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进⾏动态的调整。

17. **命令模式**(实现请求和执⾏的解耦)：命令模式的⽬的就是达到命令的发出者和执⾏者之间解耦，实现请求和执⾏分开，熟悉Struts的同学应该知道，Struts其实就是⼀种将请求和呈现分离的技术，其中必然涉及命令模式的思想！

18. **备忘录模式**(保存和恢复对象状态)：主要⽬的是保存⼀个对象的某个状态，以便在适当的时候恢复对象。

19. **状态模式**(对象状态改变时改变其⾏为)：当对象的状态改变时，同时改变其⾏为。状态模式就两点：
       1) 可以通过改变状态来获得不同的⾏为。
       2) 你的好友能同时看到你的变化。

20. **访问者模式**(数据接⼝稳定，但算法易变)：访问者模式把数据结构和作⽤于结构上的操作解耦合，使得操作集合可相对⾃由地演化。访问者模式适⽤于数据结构相对稳定算法⼜易变化的系统。因为访问者模式使得算法操作增加变得容易。访问者模式就是⼀种分离对象数据结构与⾏为的⽅法，通过这种分离，可达到为⼀个被访问者动态添加新的操作⽽⽆需做其它的修改的效果。

21. 中介者模式：中介者模式也是⽤来降低类类之间的耦合的。如果使⽤中介者模式，只需关⼼和Mediator类的关系，**具体类类之间的关系及调度交给**Mediator就⾏，这有点像spring容器的作⽤。

22. **解释器模式**(对于⼀些固定⽂法构建⼀个解释句⼦的解释器，如正则表达式)：解释器模式⽤来做各种各样的解释器，如正则表达式等的解释器。

23. **建造者模式**(创建复合对象)：⼯⼚类模式提供的是创建单个类的模式，⽽建造者模式则是将各种产品集中起来进⾏管理，⽤来创建复合对象，所谓复合对象就是指某个类具有不同的属性

24. 设计模式的六⼤原则：
       1) 开闭原则（Open Close Principle）
       开闭原则就是说对扩展开放，对修改关闭。在程序需要进⾏拓展的时候，不能去修改原有的代码，实现⼀个热插拔的效果。所以⼀句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使⽤接⼝和抽象类，后⾯的具体设计中我们会提到这点。
       2) ⾥⽒代换原则（Liskov Substitution Principle）
       ⾥⽒代换原则(Liskov Substitution Principle LSP)⾯向对象设计的基本原则之⼀。 ⾥⽒代换原则中说，任何基类可以出现的地⽅，⼦类⼀定可以出现。 LSP是继承复⽤的基⽯，只有当衍⽣类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复⽤，⽽衍⽣类也能够在基类的基础上增加新的⾏为。⾥⽒代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。⽽基类与⼦类的继承关系就是抽象化的具体实现，所以⾥⽒代换原则是对实现抽象化的具体步骤的规
       范。—— From Baidu 百科

       3) 依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：真对接⼝编程，依赖于抽象⽽不依赖于具体。
       4) 接⼝隔离原则（Interface Segregation Principle）
       这个原则的意思是：**使⽤多个隔离的接⼝，⽐使⽤单个接⼝要好。还是⼀个降低类之间的耦合度的意思**，从这⼉我们看出，其实设计模式就是⼀个软件的设计思想，从⼤型软件架构出发，为了升级和维护⽅便。所以上⽂中多次出现：降低依赖，降低耦合。
       5) 迪⽶特法则（最少知道原则）（Demeter Principle）
       为什么叫最少知道原则，就是说：⼀个实体应当尽量少的与其他实体之间发⽣相互作⽤，使得系统功能模块相对独⽴。
       6) 合成复⽤原则（Composite Reuse Principle）
       原则是尽量使⽤合成/聚合的⽅式，⽽不是使⽤继承

25. JDK中的设计模式：

       1) 单例模式：

       ```java
       java.lang.Runtime#getRuntime()
       java.awt.Desktop#getDesktop()
       java.lang.System#getSecurityManager()
       ```

       2) 责任链模式：

       ```java
       java.util.logging.Logger#log()
       javax.servlet.Filter#doFilter()
       ```

       3) 观察者模式：

       ```java
       java.util.Observer/ java.util.Observable（很少在现实世界中使⽤）
       所有实现java.util.EventListener（因此实际上各地的Swing）
       javax.servlet.http.HttpSessionBindingListener
       javax.servlet.http.HttpSessionAttributeListener
       javax.faces.event.PhaseListener
       ```

       4) 装饰器设计模式: 多个  Java IO  类中有使用。典型例子就是 Buffered  系列类如BufferedReader和BufferedWriter，它们增强了Reader 和Writer对象，以实现提升性能的  Buffer  层次的读取和写入。

26. Spring中的设计模式：
       a. **简单⼯⼚**：spring中的BeanFactory就是简单⼯⼚模式的体现，根据传⼊⼀个唯⼀的标识来获得bean对象，但是否是在传⼊
       参数后创建还是传⼊参数前创建这个要根据具体情况来定。
       b. **单例模式**：Spring下默认的bean均为singleton。
       c. **代理模式**：为其他对象提供⼀种代理以控制对这个对象的访问。 从结构上来看和Decorator模式类似，但Proxy是控制，更像
       是⼀种对功能的限制，⽽Decorator是增加职责。 spring的Proxy模式在aop中有体现，⽐如JdkDynamicAopProxy和Cglib2AopProxy。 
       d. **观察者模式**：定义对象间的⼀种⼀对多的依赖关系，当⼀个对象的状态发⽣改变时，所有依赖于它的对象都得到通知并被⾃
       动更新。spring中Observer模式常⽤的地⽅是listener的实现。如ApplicationListener。

27. Java  中什么叫单例设计模式？请用 Java  写出线程安全的单例模式 

       单例模式重点在于在整个系统上共享一些创建时较耗资源的对象。整个应用中只维护一个特定类实例，它被所有组件共同使用。Java.lang.Runtime是单例模式的经典例子。从  Java 5  开始你可以使用枚举（enum）来实现线程安全的单例。 

